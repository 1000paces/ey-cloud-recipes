#!/usr/bin/env ruby

require 'fileutils'
require 'rubygems'
require 'aws/s3'

# patch aws::s3
module AWS::S3
  class S3Object
    def <=>(other)
      DateTime.parse(self.about['last-modified']) <=> DateTime.parse(other.about['last-modified'])
    end
  end
end

# hard-coded config
config_filename = "/etc/.mongodb.backups.yml"
tmp_path = "/mnt/tmp"

# load config from yaml
if File.exist?(config_filename)
  config = YAML::load(File.read(config_filename))
  config[:environment] ||= config[:env]
  config
else
  abort "You need to have a config file at #{config_filename}"
end
         
file_path = ARGV.first
raise "No db path specified!" unless file_path

raise unless File.directory?(file_path)
fileprefix = File.split(file_path).last

timestamp = Time.now.strftime("%Y-%m-%dT%H-%M-%S")
dump_file_name = "#{fileprefix}.#{timestamp}.tar.gz"
dump_file = "#{tmp_path}/#{dump_file_name}"

begin
  # tar/gzip
  result = `tar -C #{file_path} -cvvzf #{dump_file} . --exclude=mongod.lock`
  raise result unless $?.success?

  # upload
  AWS::S3::Base.establish_connection!(
    :access_key_id     => config[:aws_secret_id],
    :secret_access_key => config[:aws_secret_key]
  )

  bucket = "ey-backup-#{Digest::SHA1.hexdigest(config[:aws_secret_id])[0..11]}"
  prefix = "#{config[:environment]}.mongodb"

  AWS::S3::S3Object.store(
    "#{prefix}/#{dump_file_name}",
    File.open(dump_file),
    bucket,
    :access => :private
  )

  # rotate backups
  replica_sets = AWS::S3::Bucket.objects(bucket, :prefix => prefix).select { |obj| File.split(obj.key).last =~ Regexp.new("^#{fileprefix}\.") }
  replica_sets.sort[0...-(config[:keep])].each do |backup|
    backup.delete
  end

ensure
  # cleanup
  result = `rm -rf #{dump_file}`
  raise result unless $?.success?
end
