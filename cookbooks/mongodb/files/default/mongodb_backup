#!/usr/bin/env ruby
require 'yaml'
require 'fileutils'
require 'rubygems'
require 'aws/s3'

# patch aws::s3
module AWS::S3
  class S3Object
    def <=>(other)
      DateTime.parse(self.about['last-modified']) <=> DateTime.parse(other.about['last-modified'])
    end
  end
end

# hard-coded config
config_filename = "/etc/.mongodb.backups.yml"
tmp_path = "/mnt/tmp"

# load config from yaml
if File.exist?(config_filename)
  config = YAML::load(File.read(config_filename))
  config[:environment] ||= config[:env]
  config
else
  abort "You need to have a config file at #{config_filename}"
end

config[:databases].each_pair do |fileprefix, database|
  timestamp = Time.now.strftime("%Y-%m-%dT%H-%M-%S")
  dump_file_name = "#{fileprefix}.#{database}.#{timestamp}.tar.gz"
  dump_path = "#{tmp_path}/#{database}.#{timestamp}"
  dump_file = "#{tmp_path}/#{dump_file_name}"

  begin
    # mongodump
    FileUtils.mkdir_p(tmp_path)
    result = `<%= @node[:mongo_path] %>/bin/mongodump --db #{database} --out #{dump_path}`
    raise result unless $?.success?

    # tar/gzip
    result = `tar -C #{dump_path} -cvvzf #{dump_file} #{database}`
    raise result unless $?.success?

    # upload
    AWS::S3::Base.establish_connection!(
      :access_key_id     => config[:aws_secret_id],
      :secret_access_key => config[:aws_secret_key]
    )

    bucket = "ey-backup-#{Digest::SHA1.hexdigest(config[:aws_secret_id])[0..11]}"
    prefix = "#{config[:environment]}.mongodb"

    AWS::S3::S3Object.store(
      "#{prefix}/#{dump_file_name}",
      File.open(dump_file),
      bucket,
      :access => :private
    )

    # rotate backups
    replica_sets = AWS::S3::Bucket.objects(bucket, :prefix => prefix).select { |obj| File.split(obj.key).last =~ Regexp.new("^#{fileprefix}\.") }
    replica_sets.sort[0...-(config[:keep])].each do |backup|
      backup.delete
    end

  ensure
    # cleanup
    result = `rm -rf #{dump_path} #{dump_file}`
    raise result unless $?.success?
  end
end
